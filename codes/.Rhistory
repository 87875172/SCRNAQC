i <- 1 # Alignment position group
j <- 1 # index of position
while (i <= n) {
if (j > length(adjs)) {
res[[i]] <- c(res[[i]], unique.pos[j])
i <- i + 1
} else if (adjs[j] == T) {
res[[i]] <- c(res[[i]], unique.pos[j])
} else if (adjs[j] == F) {
res[[i]] <- c(res[[i]], unique.pos[j])
i <- i + 1
}
j <- j + 1
}
return (res)
}
get.position.with.most.reads <- function(rdt.sub) {
res <- sort(table(rdt.sub[,position]), decreasing = T)
return (sort(as.numeric(names(res[which(res == res[1])])))[1])
}
alignment.position.correction <- function(rdt, pos.max.gap) {
rdt[,inferred_pos := position]
unique.pos <- sort(unique(rdt$position))
# consider only adjacent positions with gap <= pos.max.gap
adj.unique.pos <- get.adjacent.unique.pos(unique.pos, pos.max.gap)
pos.group <- get.adj.pos.list(adj.unique.pos, pos.max.gap)
# correct alignment position error
for (i in pos.group) {
rdt.sub <- rdt[position %in% i, ]
unique.umi.count <- table(rdt.sub$inferred_umi)
for (j in 1:l) {
rdt.sub.sub <- rdt.sub[inferred_umi == names(unique.umi.count)[j], ]
rdt[position %in% i & inferred_umi == names(unique.umi.count)[j],
inferred_pos := get.position.with.most.reads(rdt.sub.sub)]
}
}
return (rdt)
}
samdt <- read.sam(test.sam)
chr <- mixedsort(setdiff(unique(samdt[,rname]), "*"))
for (current.ref in chr) {
# correct umi mismatch
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
# correct alignment position error
rdt <- alignment.position.correction(rdt, pos.max.gap)}
alignment.position.correction <- function(rdt, pos.max.gap) {
rdt[,inferred_pos := position]
unique.pos <- sort(unique(rdt$position))
# consider only adjacent positions with gap <= pos.max.gap
adj.unique.pos <- get.adjacent.unique.pos(unique.pos, pos.max.gap)
pos.group <- get.adj.pos.list(adj.unique.pos, pos.max.gap)
# correct alignment position error
for (i in pos.group) {
rdt.sub <- rdt[position %in% i, ]
unique.umi.count <- table(rdt.sub$inferred_umi)
for (j in 1:length(unique.umi.count)) {
rdt.sub.sub <- rdt.sub[inferred_umi == names(unique.umi.count)[j], ]
rdt[position %in% i & inferred_umi == names(unique.umi.count)[j],
inferred_pos := get.position.with.most.reads(rdt.sub.sub)]
}
}
return (rdt)
}
for (current.ref in chr) {
# correct umi mismatch
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
# correct alignment position error
rdt <- alignment.position.correction(rdt, pos.max.gap)}
rdt
rdt
rdt[,.(position, inferred_pos)]
rdt[position != inferred_pos, .(umi, inferred_umi, position, inferred_pos)]
a = rdt[position != inferred_pos, .(umi, inferred_umi, position, inferred_pos)]
a = a[order(position), ]
a
a = rdt[position >800 & position<1000, .(umi, inferred_umi, position, inferred_pos)]
a
a = a[order(position), ]
a
a[1:125,]
a[1:100,]
rdt
setwd("C:/Users/31410/Google Drive/Boston University/Phdwork/Single_cell_seq/scRNA_pipeline/SCRNAQC/codes")
load(".RData")
rdt
samdt <- read.sam(test.sam)
# scRNA-seq pipeline
# Keep track of In vitro transcription RNA molecules
# Keep track of final PCR amplification products
# Input: demultiplexed SAM file
# Output: count matrix after UMI correction,
# required packages:
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(gtools))
suppressPackageStartupMessages(library(stringdist))
samdt <- read.sam(test.sam)
chr <- mixedsort(setdiff(unique(samdt[,rname]), "*"))
current.ref = chr[6]
current.ref
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
##  parameters
# umi.edit = as.numeric(opt$options$umi_edit_dist)
# umi.window = as.numeric(opt$options$window)
# umi.length = as.numeric(opt$options$umi_length)
test.sam <- "../data/CS_1017_sample_0001.sam"
fname <- last(strsplit(substr(test.sam, start=1,
stop=nchar(test.sam)-4), split="/", fixed=T)[[1]])
# acceptable umi sequence mismatches
umi.edit <- 1
# default sliding window for fragmentation discrepencies
umi.max.gap <- 20
# default sliding window for alignment position correction
pos.max.gap <- 3
#
umi.length <- 5
duplication.offset = 1024L  # SAM specification for duplication in FLAG column
output.dir <- "../res/"
# SAM file directory
out.sam <- paste0(output.dir, fname, ".tab")
umi.stats <- paste0(output.dir, fname, "_UMI_stats.tab")
umi.qc <- paste0(output.dir, fname, "_UMI_QC_plots.pdf")
umi.original.counts <- paste0(output.dir, fname, "_UMI_original_counts.txt")
umi.inferred.counts <- paste0(output.dir, fname, "_UMI_inferred_counts.txt")
umi.position.counts <- paste0(output.dir, fname, "_UMI_position_counts.txt")
# remove output file if exists
#if (file.exists(out.sam)) file.remove(out.sam)
umi.matrix <- c()
# functions
read.sam <- function(samfile){
# get the maximum number of columns per row
maxncol <- max(count.fields(samfile, sep="\t", quote="", comment.char=""))
# read in SAM file
sam <- read.table(samfile,
sep="\t",
quote="",
fill=T,
header=F,
stringsAsFactors=F,
na.strings=NULL,
comment.char="@",
col.names=1:maxncol)
colnames(sam)[1:11] <- c("qname", "flag", "rname", "position", "mapq", "cigar",
"rnext", "pnext", "tlen", "seq", "qual")
# convert to data.table object
samdt <- data.table(sam, check.names=T)
return (samdt)
}
umi.mismatch.correction <- function(samdt, current.ref, umi.max.gap, umi.edit) {
cat("Now processing", current.ref, "...\n")
# Add inferred_umi info to reference data table
rdt <- samdt[rname == current.ref,]
rdt[, c("umi", "inferred_umi") :=
tstrsplit(qname, ":", fixed=TRUE,
keep=length(tstrsplit(qname, ":", fixed=TRUE)))]
# Correct UMIs with sequencing errors by looking at UMIs in surrounding region
# get all alignment positions
unique.pos <- sort(unique(rdt$position))
unique.pos.list <- get.adj.pos.list(unique.pos, umi.max.gap)
# for each IVT fragment
for (i in unique.pos.list) {
all.umi.count <- sort(table(c(rdt[position %in% i, umi])))
if (length(all.umi.count) > 1) {
# temporary solution with only one iteration
# need a recursive solution for some special cases
sdm <- stringdistmatrix(names(all.umi.count), names(all.umi.count))
diag(sdm) <- 100
rownames(sdm) <- names(all.umi.count)
colnames(sdm) <- names(all.umi.count)
for (j in colnames(sdm)) {
if (min(sdm[j,]) <= umi.edit) {
sdm.edit.ind <- max(which(sdm[j,] <= umi.edit))
# correct current umi j within position group i
if (which(rownames(sdm) == j) < sdm.edit.ind) {
rdt[umi == j & position %in% i, inferred_umi := colnames(sdm)[sdm.edit.ind]]
}
}
}
}
}
return (rdt)
}
get.adjacent.unique.pos <- function(unique.pos, gap) {
adjs <- diff(unique.pos) <= gap
ind <- which(adjs == T)
plusone <- ind + 1
return (unique.pos[sort(union(ind, plusone))])
}
get.adj.pos.list <- function(unique.pos, gap){
adjs <- diff(unique.pos) <= gap
n <- sum(adjs == F) + 1
res <- vector("list", n)
i <- 1 # Alignment position group
j <- 1 # index of position
while (i <= n) {
if (j > length(adjs)) {
res[[i]] <- c(res[[i]], unique.pos[j])
i <- i + 1
} else if (adjs[j] == T) {
res[[i]] <- c(res[[i]], unique.pos[j])
} else if (adjs[j] == F) {
res[[i]] <- c(res[[i]], unique.pos[j])
i <- i + 1
}
j <- j + 1
}
return (res)
}
get.position.with.most.reads <- function(rdt.sub) {
res <- sort(table(rdt.sub[,position]), decreasing = T)
return (sort(as.numeric(names(res[which(res == res[1])])))[1])
}
alignment.position.correction <- function(rdt, pos.max.gap) {
rdt[,inferred_pos := position]
unique.pos <- sort(unique(rdt$position))
# consider only adjacent positions with gap <= pos.max.gap
adj.unique.pos <- get.adjacent.unique.pos(unique.pos, pos.max.gap)
pos.group <- get.adj.pos.list(adj.unique.pos, pos.max.gap)
# correct alignment position error
for (i in pos.group) {
rdt.sub <- rdt[position %in% i, ]
unique.umi.count <- table(rdt.sub$inferred_umi)
for (j in 1:length(unique.umi.count)) {
rdt.sub.sub <- rdt.sub[inferred_umi == names(unique.umi.count)[j], ]
rdt[position %in% i & inferred_umi == names(unique.umi.count)[j],
inferred_pos := get.position.with.most.reads(rdt.sub.sub)]
}
}
return (rdt)
}
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
rdt
rdt <- alignment.position.correction(rdt, pos.max.gap)
rdt
rdt
rdt[.(inferred_umi, inferred_pos)]
rdt[,.(inferred_umi, inferred_pos)]
a = rdt[,.(inferred_umi, inferred_pos)]
a = a[order(a$inferred_pos),]
a
rdt[1:5,]
head(samdt)
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
rdt <- alignment.position.correction(rdt, pos.max.gap)
rdt
rdt
samdt
samdt[,(qname, rname)]
samdt[1:200,.(qname, rname)]
samdt[100:200,.(qname, rname)]
samdt[150:200,.(qname, rname)]
samdt[rname==chr,]
chr
samdt[rname==chr[5],]
a = samdt[rname==chr[5],]
rdt[.(inferred_umi, inferred_pos)]
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
rdt <- alignment.position.correction(rdt, pos.max.gap)
a = rdt[,.(inferred_umi, inferred_pos)]
a
a = a[order(a$inferred_pos)]
a
unique(a[,.(inferred_umi,inferred_pos)])
b =
unique(a[,.(inferred_umi,inferred_pos)])
b
a[1:50,]
b[1:10,]
a[10:20,]
b[1:20]
a
a[150:200,]
a[100:150,]
b
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
rdt <- alignment.position.correction(rdt, pos.max.gap)
a = rdt[,.(inferred_umi, inferred_pos)]
a
b = unique(a[,.(inferred_umi,inferred_pos)]
unique.pos <- sort(unique(rdt$inferred_pos))
b = unique(a[,.(inferred_umi,inferred_pos)]
unique.pos <- sort(unique(rdt$inferred_pos))
b = unique(a[,.(inferred_umi,inferred_pos)])
b
a = a[order(a$inferred_pos)]
b
b = unique(a[,.(inferred_umi,inferred_pos)])
b
fragment <- rdt[,.(inferred_umi, inferred_pos)]
fragment.ordered <- fragment[order(fragment$inferred_pos)]
unique.fragments = unique(fragment.ordered[,.(inferred_umi,inferred_pos)])
unique.fragments
unique.fragments[1,]
a = rdt[.(inferred_umi,inferred_pos),]
a = rdt[,.(inferred_umi,inferred_pos)]
a
b =
unique.fragments[1,]
b
b %in% a
a[inferred_umi==b[1],]
b[1]
b[[1]]
b[[2]]
a[inferred_umi==b[[1]],]
a[inferred_umi==b[[1]] & inferred_pos,]
a[inferred_umi==b[[1]] & inferred_pos==b[[2]],]
nrow(a[inferred_umi==b[[1]] & inferred_pos==b[[2]],])
a
b
unique.fragments
class(unique.fragments)
res <- unique.fragments[,inferred_umi]
res
res <- unique.fragments[,list(inferred_umi)]
res
frag[[1]]
frag <- unique.fragments[i,]
frag[[1]]
i = 1
frag <- unique.fragments[i,]
frag
frag[[1]]
res
num <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
num
frag
res[inferred_umi == frag[[1]], num := num]
res
get.pcr.duplicates <- function(unique.fragments, rdt) {
for (i in 1:nrow(unique.fragments)) {
frag <- unique.fragments[i,]
num <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
unique.fragments[i, num := num]
}
return (unique.fragments)
}
a = get.pcr.duplicates(unique.fragments, rdt)
a
a
get.pcr.duplicates <- function(unique.fragments, rdt) {
for (i in 1:nrow(unique.fragments)) {
frag <- unique.fragments[i,]
num <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
unique.fragments[i, num := num]
}
return (unique.fragments)
}
a = get.pcr.duplicates(unique.fragments, rdt)
a
a
unique.fragments
nrow(unique.fragments)
frag <- unique.fragments[i,]
num <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
frag
num
unique.fragments[i,]
n <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
unique.fragments[i, num := n]
unique.fragments[i,]
get.pcr.duplicates <- function(unique.fragments, rdt) {
for (i in 1:nrow(unique.fragments)) {
frag <- unique.fragments[i,]
n <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
unique.fragments[i, num := n]
}
return (unique.fragments)
}
a = get.pcr.duplicates(unique.fragments, rdt)
a
a
fragment <- rdt[,.(inferred_umi, inferred_pos, rname)]
fragment.ordered <- fragment[order(fragment$inferred_pos)]
unique.fragments = unique(fragment.ordered[,.(inferred_umi,inferred_pos)])
unique.fragments
fragment.ordered
fragment.ordered
unique.fragments = unique(fragment.ordered, fromLast=T)
unique.fragments
unique.fragments = unique(fragment.ordered, fromLast=F)
unique.fragments
fragment.ordered
unique(fragment.ordered)
unique(fragment.ordered, fromLast=T)
unique(fragment.ordered, fromLast=F)
fragment <- rdt[,.(inferred_umi, inferred_pos, rname)]
fragment
unique.fragments <- unique(fragment[order(fragment$inferred_pos)])
unique.fragments
r
get.pcr.duplicates <- function(unique.fragments, rdt, rname) {
for (i in 1:nrow(unique.fragments)) {
frag <- unique.fragments[i,]
n <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
unique.fragments[i, num := n]
}
return (unique.fragments)
}
fragment <- rdt[,.(inferred_umi, inferred_pos, rname)]
unique.fragments <- unique(fragment[order(fragment$inferred_pos)])
num.pcr.products = get.pcr.duplicates(unique.fragments, rdt, rname)
num.pcr.products
num.pcr.products
rname
get.pcr.duplicates <- function(rdt) {
reads <- rdt[,.(inferred_umi, inferred_pos, rname)]
unique.fragments <- unique(reads[order(reads$inferred_pos)])
for (i in 1:nrow(unique.fragments)) {
frag <- unique.fragments[i,]
n <- nrow(rdt[inferred_umi==frag[[1]] & inferred_pos==frag[[2]],])
unique.fragments[i, num := n]
}
return (unique.fragments)
}
num.pcr.products2 = get.pcr.duplicates(rdt)
num.pcr.products2
num.pcr.products2
num.pcr.products
rdt[umi!=inferred_umi,]
rdt
res.table <- list()
res.table
res.table <- list()
for (current.ref in chr) {
# correct umi mismatch
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
# correct alignment position error
rdt <- alignment.position.correction(rdt, pos.max.gap)
# Now that UMIs have been fixed, go through each position and pick one read to
# represent each UMI. Positions with more reads with that UMI and that are more 5'
# are given higher priority. One read randomly selected to be the non-duplicate
# Metrics to report:
# Number of PCR priducts per IVT fragment
num.pcr.products = get.pcr.duplicates(rdt)
# Distribution of average UMI edit distance of all reads
res.table <- rbindlist(list(res.table,
rdt[,c("rname", "position","inferred_pos",
"umi", "inferred_umi")]),
use.names=F, fill=F, idcol=F)
}
res.table
nrow(res.table[position != inferred_pos,])
nrow(res.table[umi != inferred_umi,])
num.pcr.products
num.pcr.products <- list()
for (current.ref in chr) {
# correct umi mismatch
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
# correct alignment position error
rdt <- alignment.position.correction(rdt, pos.max.gap)
# Now that UMIs have been fixed, go through each position and pick one read to
# represent each UMI. Positions with more reads with that UMI and that are more 5'
# are given higher priority. One read randomly selected to be the non-duplicate
# Metrics to report:
# Number of PCR priducts per IVT fragment
num.pcr.products <- rbindlist(list(num.pcr.products, get.pcr.duplicates(rdt)),
use.names=F, fill=F, idcol=F)
# Distribution of average UMI edit distance of all reads
res.table <- rbindlist(list(res.table,
rdt[,c("rname", "position","inferred_pos",
"umi", "inferred_umi")]),
use.names=F, fill=F, idcol=F)
}
num.pcr.products
hist(num.pcr.products$num)
hist(log(num.pcr.products$num))
hist(num.pcr.products$num)
hist(num.pcr.products$num, breaks=20)
hist(num.pcr.products$num, breaks=200)
max(num.pcr.products$num)
boxplot(num.pcr.products$num)
hist(num.pcr.products$num, breaks=200)
hist(log(num.pcr.products$num), breaks=200)
boxplot(log(num.pcr.products$num))
hist(num.pcr.products$num)
table(num.pcr.products$num)
median(num.pcr.products$num)
mean(num.pcr.products$num)
hist(num.pcr.products$num, probability=T)
num.pcr.products
nrow(num.pcr.products)
nrow(res.table)
res.table <- list()
num.pcr.products <- list()
for (current.ref in chr) {
# correct umi mismatch
rdt <- umi.mismatch.correction(samdt, current.ref, umi.max.gap, umi.edit)
# correct alignment position error
rdt <- alignment.position.correction(rdt, pos.max.gap)
# Now that UMIs have been fixed, go through each position and pick one read to
# represent each UMI. Positions with more reads with that UMI and that are more 5'
# are given higher priority. One read randomly selected to be the non-duplicate
# Metrics to report:
# Number of PCR priducts per IVT fragment
num.pcr.products <- rbindlist(list(num.pcr.products, get.pcr.duplicates(rdt)),
use.names=F, fill=F, idcol=F)
# Distribution of average UMI edit distance of all reads
res.table <- rbindlist(list(res.table,
rdt[,c("rname", "position","inferred_pos",
"umi", "inferred_umi")]),
use.names=F, fill=F, idcol=F)
}
nrow(res.table)
nrow(num.pcr.products)
res.table
num.umi.mismatch
num.umi.mismatch <- nrow(res.table[umi != inferred_umi,])
num.pos.shift <- nrow(res.table[position != inferred_pos,])
num.umi.mismatch
num.pos.shift
num.pos.shift
save.image()
